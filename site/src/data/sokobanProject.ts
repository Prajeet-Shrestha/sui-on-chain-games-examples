import type { FileEntry } from "./mockProject";

export const SOKOBAN_FILES: FileEntry[] = [
  {
    "path": "Move.toml",
    "size": 358,
    "content": "[package]\nname = \"sokoban\"\nedition = \"2024.beta\"\n\n[dependencies]\nSui = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/mainnet\", override = true }\nworld = { git = \"https://github.com/prajeet-shrestha/sui-game-engine.git\", subdir = \"world\", rev = \"main\" }\n\n[addresses]\nsokoban = \"0x0\"\n"
  },
  {
    "path": "sources/game.move",
    "size": 16602,
    "content": "/// Sokoban â€” On-Chain Box Pusher\n/// Player submits entire solution as a vector<u8> of directions.\n/// Contract simulates all moves and verifies the puzzle is solved.\n/// Each start_level creates a fresh Grid + GameSession per player.\n#[allow(unused_const, unused_field, lint(public_entry))]\nmodule sokoban::game;\n\nuse std::ascii;\nuse sui::clock::Clock;\nuse sui::event;\nuse entity::entity::{Self, Entity};\nuse world::world::{Self, World};\nuse systems::grid_sys::{Self, Grid};\nuse components::position;\n\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ERROR CONSTANTS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst EInvalidState: u64 = 100;\nconst ENotPlayer: u64 = 101;\nconst EInvalidDirection: u64 = 102;\nconst ETooManyMoves: u64 = 103;\nconst EBlockedByWall: u64 = 104;\nconst EOutOfBounds: u64 = 105;\nconst EBlockedByBox: u64 = 106;\nconst EPuzzleNotSolved: u64 = 107;\nconst EInvalidLevel: u64 = 108;\nconst EAlreadyStarted: u64 = 109;\nconst ELevelNotActive: u64 = 110;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// GAME CONSTANTS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst STATE_LOBBY: u8 = 0;\nconst STATE_ACTIVE: u8 = 1;\nconst STATE_FINISHED: u8 = 2;\n\n// Directions\nconst DIR_UP: u8 = 0;\nconst DIR_RIGHT: u8 = 1;\nconst DIR_DOWN: u8 = 2;\nconst DIR_LEFT: u8 = 3;\n\n// Marker types (symbol field)\nconst MARKER_PLAYER: u64 = 0;\nconst MARKER_WALL: u64 = 1;\nconst MARKER_BOX: u64 = 2;\n\n// Grid size\nconst GRID_W: u64 = 6;\nconst GRID_H: u64 = 6;\n\n// Max levels\nconst MAX_LEVEL: u64 = 5;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// GAME SESSION (one per player per level start)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\npublic struct GameSession has key {\n    id: UID,\n    state: u8,\n    player: address,\n    level_id: u64,\n    max_moves: u64,\n    // Goal positions (parallel arrays)\n    goal_xs: vector<u64>,\n    goal_ys: vector<u64>,\n    // Scoring\n    best_score: Option<u64>,\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// EVENTS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\npublic struct WorldCreated has copy, drop {\n    world_id: ID,\n}\n\npublic struct LevelStarted has copy, drop {\n    session_id: ID,\n    grid_id: ID,\n    level_id: u64,\n    player: address,\n}\n\npublic struct LevelComplete has copy, drop {\n    session_id: ID,\n    level_id: u64,\n    move_count: u64,\n    is_new_best: bool,\n}\n\npublic struct SolutionFailed has copy, drop {\n    session_id: ID,\n    level_id: u64,\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// INIT â€” Creates World only (shared singleton)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nfun init(ctx: &mut TxContext) {\n    let world = world::create_world(\n        ascii::string(b\"Sokoban\"),\n        10000,  // max entities â€” high cap since each player spawns entities\n        ctx,\n    );\n\n    event::emit(WorldCreated {\n        world_id: object::id(&world),\n    });\n\n    world::share(world);\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ENTRY FUNCTIONS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n/// Start a level â€” creates a fresh Grid + GameSession and spawns all entities.\n/// Each player gets their own isolated board.\npublic entry fun start_level(\n    world: &mut World,\n    level_id: u64,\n    clock: &Clock,\n    ctx: &mut TxContext,\n) {\n    assert!(level_id >= 1 && level_id <= MAX_LEVEL, EInvalidLevel);\n\n    let player_addr = ctx.sender();\n\n    // Load level data\n    let (wall_xs, wall_ys, box_xs, box_ys, goal_xs, goal_ys, px, py, max_moves) =\n        get_level_data(level_id);\n\n    // Create a fresh grid for this player's session\n    let mut grid = world::create_grid(world, GRID_W, GRID_H, ctx);\n\n    // Create a fresh session for this player\n    let session = GameSession {\n        id: object::new(ctx),\n        state: STATE_ACTIVE,\n        player: player_addr,\n        level_id,\n        max_moves,\n        goal_xs,\n        goal_ys,\n        best_score: option::none(),\n    };\n\n    // Spawn walls\n    let num_walls = vector::length(&wall_xs);\n    let mut i = 0;\n    while (i < num_walls) {\n        let wx = *vector::borrow(&wall_xs, i);\n        let wy = *vector::borrow(&wall_ys, i);\n        let wall = world::spawn_tile(world, wx, wy, (MARKER_WALL as u8), clock, ctx);\n        world::place(world, &mut grid, object::id(&wall), wx, wy);\n        entity::share(wall);\n        i = i + 1;\n    };\n\n    // Spawn boxes\n    let num_boxes = vector::length(&box_xs);\n    i = 0;\n    while (i < num_boxes) {\n        let bx = *vector::borrow(&box_xs, i);\n        let by = *vector::borrow(&box_ys, i);\n        let box_entity = world::spawn_tile(world, bx, by, (MARKER_BOX as u8), clock, ctx);\n        world::place(world, &mut grid, object::id(&box_entity), bx, by);\n        entity::share(box_entity);\n        i = i + 1;\n    };\n\n    // Spawn player\n    let player_entity = world::spawn_tile(world, px, py, (MARKER_PLAYER as u8), clock, ctx);\n    world::place(world, &mut grid, object::id(&player_entity), px, py);\n    entity::share(player_entity);\n\n    event::emit(LevelStarted {\n        session_id: object::id(&session),\n        grid_id: object::id(&grid),\n        level_id,\n        player: player_addr,\n    });\n\n    // Share both â€” each player gets their own pair\n    world::share_grid(grid);\n    transfer::share_object(session);\n}\n\n/// Submit a solution â€” vector of directions. All-or-nothing.\n/// The player_entity must be passed first, then all box entities in spawn order.\n/// Session and grid are the player's own per-session objects.\npublic entry fun submit_solution(\n    session: &mut GameSession,\n    world: &World,\n    grid: &mut Grid,\n    player_entity: &mut Entity,\n    mut box_entities: vector<Entity>,\n    directions: vector<u8>,\n    ctx: &TxContext,\n) {\n    assert!(session.state == STATE_ACTIVE, ELevelNotActive);\n    assert!(session.player == ctx.sender(), ENotPlayer);\n\n    let num_moves = vector::length(&directions);\n    assert!(num_moves <= session.max_moves, ETooManyMoves);\n\n    // Simulate all moves\n    let mut i = 0;\n    while (i < num_moves) {\n        let dir = *vector::borrow(&directions, i);\n        assert!(dir <= 3, EInvalidDirection);\n\n        // Get current player position\n        let player_pos = position::borrow(player_entity);\n        let player_x = position::x(player_pos);\n        let player_y = position::y(player_pos);\n\n        // Calculate target position\n        let (target_x, target_y, valid) = calc_target(player_x, player_y, dir);\n        assert!(valid, EOutOfBounds);\n\n        // Check what's at target\n        if (grid_sys::is_occupied(grid, target_x, target_y)) {\n            // Something is there â€” could be wall or box\n            let target_entity_id = grid_sys::get_entity_at(grid, target_x, target_y);\n            \n            // Find if it's a box\n            let (is_box, box_idx) = find_box_entity(&box_entities, target_entity_id);\n\n            if (is_box) {\n                // It's a box â€” try to push it\n                let (push_x, push_y, push_valid) = calc_target(target_x, target_y, dir);\n                assert!(push_valid, EOutOfBounds);\n                assert!(!grid_sys::is_occupied(grid, push_x, push_y), EBlockedByBox);\n\n                // Move box: remove from grid, update position, re-place\n                let box_ref = vector::borrow_mut(&mut box_entities, box_idx);\n                world::remove_from_grid(world, grid, target_x, target_y);\n                let box_pos = position::borrow_mut(box_ref);\n                position::set(box_pos, push_x, push_y);\n                world::place(world, grid, object::id(box_ref), push_x, push_y);\n            } else {\n                // It's a wall â€” blocked\n                abort EBlockedByWall\n            };\n        };\n\n        // Move player: remove from grid, update position, re-place\n        world::remove_from_grid(world, grid, player_x, player_y);\n        let p_pos = position::borrow_mut(player_entity);\n        position::set(p_pos, target_x, target_y);\n        world::place(world, grid, object::id(player_entity), target_x, target_y);\n\n        i = i + 1;\n    };\n\n    // Check win condition: all goals must have a box\n    let num_goals = vector::length(&session.goal_xs);\n    let mut g = 0;\n    while (g < num_goals) {\n        let gx = *vector::borrow(&session.goal_xs, g);\n        let gy = *vector::borrow(&session.goal_ys, g);\n        \n        // Check if there's a box at this goal position\n        let has_box = is_box_at_position(&box_entities, gx, gy);\n        assert!(has_box, EPuzzleNotSolved);\n        g = g + 1;\n    };\n\n    // Puzzle solved!\n    let is_new_best = if (option::is_some(&session.best_score)) {\n        num_moves < *option::borrow(&session.best_score)\n    } else {\n        true\n    };\n\n    if (is_new_best) {\n        session.best_score = option::some(num_moves);\n    };\n\n    session.state = STATE_FINISHED;\n\n    event::emit(LevelComplete {\n        session_id: object::id(session),\n        level_id: session.level_id,\n        move_count: num_moves,\n        is_new_best,\n    });\n\n    // Return box entities to shared\n    let mut j = 0;\n    let len = vector::length(&box_entities);\n    while (j < len) {\n        let box_e = vector::pop_back(&mut box_entities);\n        entity::share(box_e);\n        j = j + 1;\n    };\n    vector::destroy_empty(box_entities);\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// INTERNAL HELPERS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n/// Calculate target position from current position + direction.\n/// Returns (x, y, is_valid). Invalid if out of bounds.\nfun calc_target(x: u64, y: u64, dir: u8): (u64, u64, bool) {\n    if (dir == DIR_UP) {\n        if (y == 0) { return (x, y, false) };\n        (x, y - 1, true)\n    } else if (dir == DIR_RIGHT) {\n        if (x + 1 >= GRID_W) { return (x, y, false) };\n        (x + 1, y, true)\n    } else if (dir == DIR_DOWN) {\n        if (y + 1 >= GRID_H) { return (x, y, false) };\n        (x, y + 1, true)\n    } else {\n        // DIR_LEFT\n        if (x == 0) { return (x, y, false) };\n        (x - 1, y, true)\n    }\n}\n\n/// Find a box entity by its on-chain ID in the box_entities vector.\n/// Returns (is_box, index).\nfun find_box_entity(box_entities: &vector<Entity>, target_id: ID): (bool, u64) {\n    let len = vector::length(box_entities);\n    let mut i = 0;\n    while (i < len) {\n        let box_e = vector::borrow(box_entities, i);\n        if (object::id(box_e) == target_id) {\n            return (true, i)\n        };\n        i = i + 1;\n    };\n    (false, 0)\n}\n\n/// Check if any box entity is at the given position.\nfun is_box_at_position(box_entities: &vector<Entity>, x: u64, y: u64): bool {\n    let len = vector::length(box_entities);\n    let mut i = 0;\n    while (i < len) {\n        let box_e = vector::borrow(box_entities, i);\n        let pos = position::borrow(box_e);\n        if (position::x(pos) == x && position::y(pos) == y) {\n            return true\n        };\n        i = i + 1;\n    };\n    false\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// LEVEL DATA\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n/// Returns (wall_xs, wall_ys, box_xs, box_ys, goal_xs, goal_ys, player_x, player_y, max_moves)\nfun get_level_data(level_id: u64): (\n    vector<u64>, vector<u64>,   // walls\n    vector<u64>, vector<u64>,   // boxes\n    vector<u64>, vector<u64>,   // goals\n    u64, u64,                    // player start\n    u64,                         // max moves\n) {\n    if (level_id == 1) {\n        // Level 1: \"First Steps\" â€” 2 boxes, easy\n        // . . . . . .\n        // . # # # # .\n        // . . . . G .\n        // . . B B G .\n        // . . . @ . .\n        // . . . . . .\n        (\n            vector[1, 2, 3, 4],          // wall_xs\n            vector[1, 1, 1, 1],          // wall_ys\n            vector[2, 3],                // box_xs\n            vector[3, 3],                // box_ys\n            vector[4, 4],                // goal_xs\n            vector[2, 3],                // goal_ys\n            3, 4,                        // player start\n            12,                          // max_moves\n        )\n    } else if (level_id == 2) {\n        // Level 2: \"Open Field\" â€” 2 boxes, navigate around\n        // . . . . . .\n        // . . . . . .\n        // . G . B . .\n        // . . # . . .\n        // . G . B . .\n        // . . . @ . .\n        (\n            vector[2],                   // wall_xs\n            vector[3],                   // wall_ys\n            vector[3, 3],                // box_xs\n            vector[2, 4],                // box_ys\n            vector[1, 1],                // goal_xs\n            vector[2, 4],                // goal_ys\n            3, 5,                        // player start\n            16,                          // max_moves\n        )\n    } else if (level_id == 3) {\n        // Level 3: \"Storage Room\" â€” 3 boxes, zigzag\n        // . . . . . .\n        // . . # # # .\n        // . . . . . .\n        // . G B . . .\n        // . G B . . .\n        // . G B @ . .\n        (\n            vector[2, 3, 4],             // wall_xs\n            vector[1, 1, 1],             // wall_ys\n            vector[2, 2, 2],             // box_xs\n            vector[3, 4, 5],             // box_ys\n            vector[1, 1, 1],             // goal_xs\n            vector[3, 4, 5],             // goal_ys\n            3, 5,                        // player start\n            14,                          // max_moves\n        )\n    } else if (level_id == 4) {\n        // Level 4: \"Crossroads\" â€” 2 boxes, opposite directions\n        // . . . . . .\n        // . . . # . .\n        // . G . B . .\n        // . . . . . .\n        // . . B . G .\n        // . . @ # . .\n        (\n            vector[3, 3],                // wall_xs\n            vector[1, 5],                // wall_ys\n            vector[3, 2],                // box_xs\n            vector[2, 4],                // box_ys\n            vector[1, 4],                // goal_xs\n            vector[2, 4],                // goal_ys\n            2, 5,                        // player start\n            14,                          // max_moves\n        )\n    } else {\n        // Level 5: \"The Gauntlet\" â€” 3 boxes, complex\n        // . . . . . .\n        // . # . # . .\n        // . . B . G .\n        // G . B . . .\n        // . . B . G .\n        // . # @ # . .\n        (\n            vector[1, 3, 1, 3],          // wall_xs\n            vector[1, 1, 5, 5],          // wall_ys\n            vector[2, 2, 2],             // box_xs\n            vector[2, 3, 4],             // box_ys\n            vector[4, 0, 4],             // goal_xs\n            vector[2, 3, 4],             // goal_ys\n            2, 5,                        // player start\n            20,                          // max_moves\n        )\n    }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// TEST HELPERS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n#[test_only]\npublic fun init_for_testing(ctx: &mut TxContext) {\n    init(ctx);\n}\n"
  },
  {
    "path": "sources/game_tests.move",
    "size": 6258,
    "content": "/// Sokoban tests â€” per-player sessions, full game loop.\n#[test_only]\nmodule sokoban::game_tests;\n\nuse sui::test_scenario;\nuse sui::clock;\nuse sokoban::game::{Self, GameSession};\nuse world::world::World;\nuse systems::grid_sys::Grid;\nuse entity::entity::Entity;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// HELPERS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst PLAYER_A: address = @0xA1;\nconst PLAYER_B: address = @0xB2;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// TEST: Start level creates Grid + Session\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n#[test]\nfun test_start_level() {\n    let mut scenario = test_scenario::begin(PLAYER_A);\n\n    // Deploy â€” creates World only\n    game::init_for_testing(test_scenario::ctx(&mut scenario));\n\n    // Start level 1 â€” creates Grid + GameSession\n    test_scenario::next_tx(&mut scenario, PLAYER_A);\n    {\n        let mut world = test_scenario::take_shared<World>(&scenario);\n        let c = clock::create_for_testing(test_scenario::ctx(&mut scenario));\n\n        game::start_level(\n            &mut world,\n            1,  // level_id\n            &c,\n            test_scenario::ctx(&mut scenario),\n        );\n\n        test_scenario::return_shared(world);\n        clock::destroy_for_testing(c);\n    };\n\n    // Verify Grid and Session were created\n    test_scenario::next_tx(&mut scenario, PLAYER_A);\n    {\n        let session = test_scenario::take_shared<GameSession>(&scenario);\n        let grid = test_scenario::take_shared<Grid>(&scenario);\n\n        test_scenario::return_shared(session);\n        test_scenario::return_shared(grid);\n    };\n\n    test_scenario::end(scenario);\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// TEST: Solve Level 1 with valid solution\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n#[test]\nfun test_solve_level_1() {\n    let mut scenario = test_scenario::begin(PLAYER_A);\n\n    // Deploy\n    game::init_for_testing(test_scenario::ctx(&mut scenario));\n\n    // Start level 1\n    test_scenario::next_tx(&mut scenario, PLAYER_A);\n    {\n        let mut world = test_scenario::take_shared<World>(&scenario);\n        let c = clock::create_for_testing(test_scenario::ctx(&mut scenario));\n\n        game::start_level(\n            &mut world, 1, &c,\n            test_scenario::ctx(&mut scenario),\n        );\n\n        test_scenario::return_shared(world);\n        clock::destroy_for_testing(c);\n    };\n\n    // Submit solution: [LEFT, UP, RIGHT, LEFT, LEFT, UP, RIGHT, RIGHT] = [3,0,1,3,3,0,1,1]\n    test_scenario::next_tx(&mut scenario, PLAYER_A);\n    {\n        let mut session = test_scenario::take_shared<GameSession>(&scenario);\n        let world = test_scenario::take_shared<World>(&scenario);\n        let mut grid = test_scenario::take_shared<Grid>(&scenario);\n\n        // Get player entity and box entities\n        let mut player = test_scenario::take_shared<Entity>(&scenario);\n        let box1 = test_scenario::take_shared<Entity>(&scenario);\n        let box2 = test_scenario::take_shared<Entity>(&scenario);\n\n        let directions = vector[3, 0, 1, 3, 3, 0, 1, 1];\n        let box_entities = vector[box1, box2];\n\n        game::submit_solution(\n            &mut session,\n            &world,\n            &mut grid,\n            &mut player,\n            box_entities,\n            directions,\n            test_scenario::ctx(&mut scenario),\n        );\n\n        test_scenario::return_shared(session);\n        test_scenario::return_shared(world);\n        test_scenario::return_shared(grid);\n        test_scenario::return_shared(player);\n    };\n\n    test_scenario::end(scenario);\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// TEST: Two players can start the same level independently\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n#[test]\nfun test_two_players_independent() {\n    let mut scenario = test_scenario::begin(PLAYER_A);\n\n    // Deploy\n    game::init_for_testing(test_scenario::ctx(&mut scenario));\n\n    // Player A starts level 1\n    test_scenario::next_tx(&mut scenario, PLAYER_A);\n    {\n        let mut world = test_scenario::take_shared<World>(&scenario);\n        let c = clock::create_for_testing(test_scenario::ctx(&mut scenario));\n\n        game::start_level(\n            &mut world, 1, &c,\n            test_scenario::ctx(&mut scenario),\n        );\n\n        test_scenario::return_shared(world);\n        clock::destroy_for_testing(c);\n    };\n\n    // Player B starts level 1 â€” gets their own Grid + Session\n    test_scenario::next_tx(&mut scenario, PLAYER_B);\n    {\n        let mut world = test_scenario::take_shared<World>(&scenario);\n        let c = clock::create_for_testing(test_scenario::ctx(&mut scenario));\n\n        game::start_level(\n            &mut world, 1, &c,\n            test_scenario::ctx(&mut scenario),\n        );\n\n        test_scenario::return_shared(world);\n        clock::destroy_for_testing(c);\n    };\n\n    // Verify BOTH sessions and grids exist (2 of each)\n    test_scenario::next_tx(&mut scenario, PLAYER_A);\n    {\n        let session_a = test_scenario::take_shared<GameSession>(&scenario);\n        let session_b = test_scenario::take_shared<GameSession>(&scenario);\n        let grid_a = test_scenario::take_shared<Grid>(&scenario);\n        let grid_b = test_scenario::take_shared<Grid>(&scenario);\n\n        test_scenario::return_shared(session_a);\n        test_scenario::return_shared(session_b);\n        test_scenario::return_shared(grid_a);\n        test_scenario::return_shared(grid_b);\n    };\n\n    test_scenario::end(scenario);\n}\n"
  },
  {
    "path": "frontend/package.json",
    "size": 853,
    "content": "{\n  \"name\": \"sokoban-frontend\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"tsc -b && vite build\",\n    \"lint\": \"eslint .\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"@mysten/dapp-kit-react\": \"^1.0.2\",\n    \"@mysten/sui\": \"^2.4.0\",\n    \"@tanstack/react-query\": \"^5.90.21\",\n    \"react\": \"^19.2.0\",\n    \"react-dom\": \"^19.2.0\",\n    \"zustand\": \"^5.0.11\"\n  },\n  \"devDependencies\": {\n    \"@eslint/js\": \"^9.39.1\",\n    \"@types/node\": \"^24.10.1\",\n    \"@types/react\": \"^19.2.7\",\n    \"@types/react-dom\": \"^19.2.3\",\n    \"@vitejs/plugin-react\": \"^5.1.1\",\n    \"eslint\": \"^9.39.1\",\n    \"eslint-plugin-react-hooks\": \"^7.0.1\",\n    \"eslint-plugin-react-refresh\": \"^0.4.24\",\n    \"globals\": \"^16.5.0\",\n    \"typescript\": \"~5.9.3\",\n    \"typescript-eslint\": \"^8.48.0\",\n    \"vite\": \"^7.3.1\"\n  }\n}\n"
  },
  {
    "path": "frontend/index.html",
    "size": 357,
    "content": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>frontend</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/src/main.tsx\"></script>\n  </body>\n</html>\n"
  },
  {
    "path": "frontend/vite.config.ts",
    "size": 252,
    "content": "import { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  base: '/sokoban/',\n  plugins: [react()],\n  resolve: {\n    alias: {\n      '@': '/src',\n    },\n  },\n  build: {\n    target: 'esnext',\n  },\n});\n"
  },
  {
    "path": "frontend/tsconfig.json",
    "size": 119,
    "content": "{\n  \"files\": [],\n  \"references\": [\n    { \"path\": \"./tsconfig.app.json\" },\n    { \"path\": \"./tsconfig.node.json\" }\n  ]\n}\n"
  },
  {
    "path": "frontend/tsconfig.app.json",
    "size": 732,
    "content": "{\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"./node_modules/.tmp/tsconfig.app.tsbuildinfo\",\n    \"target\": \"ES2022\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2022\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"types\": [\"vite/client\"],\n    \"skipLibCheck\": true,\n\n    /* Bundler mode */\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"moduleDetection\": \"force\",\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\",\n\n    /* Linting */\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"erasableSyntaxOnly\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedSideEffectImports\": true\n  },\n  \"include\": [\"src\"]\n}\n"
  },
  {
    "path": "frontend/tsconfig.node.json",
    "size": 653,
    "content": "{\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"./node_modules/.tmp/tsconfig.node.tsbuildinfo\",\n    \"target\": \"ES2023\",\n    \"lib\": [\"ES2023\"],\n    \"module\": \"ESNext\",\n    \"types\": [\"node\"],\n    \"skipLibCheck\": true,\n\n    /* Bundler mode */\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"moduleDetection\": \"force\",\n    \"noEmit\": true,\n\n    /* Linting */\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"erasableSyntaxOnly\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedSideEffectImports\": true\n  },\n  \"include\": [\"vite.config.ts\"]\n}\n"
  },
  {
    "path": "frontend/eslint.config.js",
    "size": 616,
    "content": "import js from '@eslint/js'\nimport globals from 'globals'\nimport reactHooks from 'eslint-plugin-react-hooks'\nimport reactRefresh from 'eslint-plugin-react-refresh'\nimport tseslint from 'typescript-eslint'\nimport { defineConfig, globalIgnores } from 'eslint/config'\n\nexport default defineConfig([\n  globalIgnores(['dist']),\n  {\n    files: ['**/*.{ts,tsx}'],\n    extends: [\n      js.configs.recommended,\n      tseslint.configs.recommended,\n      reactHooks.configs.flat.recommended,\n      reactRefresh.configs.vite,\n    ],\n    languageOptions: {\n      ecmaVersion: 2020,\n      globals: globals.browser,\n    },\n  },\n])\n"
  },
  {
    "path": "frontend/src/main.tsx",
    "size": 700,
    "content": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { DAppKitProvider } from '@mysten/dapp-kit-react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { dAppKit } from './dApp-kit';\nimport App from './App';\nimport './index.css';\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 2_000,\n      refetchOnWindowFocus: true,\n    },\n  },\n});\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <QueryClientProvider client={queryClient}>\n      <DAppKitProvider dAppKit={dAppKit}>\n        <App />\n      </DAppKitProvider>\n    </QueryClientProvider>\n  </React.StrictMode>,\n);\n"
  },
  {
    "path": "frontend/src/App.tsx",
    "size": 6225,
    "content": "import { useState } from 'react';\nimport { useWalletConnection, ConnectButton } from '@mysten/dapp-kit-react';\nimport { Header } from './components/Header';\nimport { LevelSelect } from './components/LevelSelect';\nimport { GameBoard } from './components/GameBoard';\nimport { SpriteAnimation } from './components/SpriteAnimation';\nimport { MoveControls } from './components/MoveControls';\nimport { useGameStore } from './stores/gameStore';\nimport { useGameActions } from './hooks/useGameActions';\nimport { LEVELS } from './constants';\n\ntype Screen = 'select' | 'play' | 'victory';\n\nfunction App() {\n  const { isConnected } = useWalletConnection();\n  const [screen, setScreen] = useState<Screen>('select');\n  const moveQueue = useGameStore((s) => s.moveQueue);\n  const isSolved = useGameStore((s) => s.isSolved);\n  const levelId = useGameStore((s) => s.levelId);\n  const levelData = useGameStore((s) => s.levelData);\n  const playerEntityId = useGameStore((s) => s.playerEntityId);\n  const boxEntityIds = useGameStore((s) => s.boxEntityIds);\n  const sessionId = useGameStore((s) => s.sessionId);\n  const gridId = useGameStore((s) => s.gridId);\n  const [submitting, setSubmitting] = useState(false);\n  const [submitMoves, setSubmitMoves] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  const { submitSolution } = useGameActions();\n\n  const level = levelId ? LEVELS.find((l) => l.id === levelId) : null;\n  const solved = isSolved();\n\n  async function handleSubmit() {\n    if (!solved || !levelId || moveQueue.length === 0) return;\n    if (!playerEntityId || boxEntityIds.length === 0 || !sessionId || !gridId) {\n      setError('Entity IDs not found. Try restarting the level.');\n      return;\n    }\n    setSubmitting(true);\n    setError(null);\n    try {\n      await submitSolution(moveQueue, playerEntityId, boxEntityIds, sessionId, gridId);\n      setSubmitMoves(moveQueue.length);\n      setScreen('victory');\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Submission failed');\n    } finally {\n      setSubmitting(false);\n    }\n  }\n\n  function handleBackToSelect() {\n    setScreen('select');\n    setError(null);\n  }\n\n  return (\n    <>\n      <Header />\n\n      {!isConnected ? (\n        <div className=\"connect-prompt\">\n          <SpriteAnimation\n            src={`${import.meta.env.BASE_URL}Pink_Monster_PushRight_6.png`}\n            frameCount={6}\n            frameWidth={32}\n            frameHeight={32}\n            fps={8}\n            scale={4}\n            className=\"hero-sprite\"\n          />\n          <h2>ğŸ“¦ Sokoban On-Chain</h2>\n          <p>Connect your Sui wallet to start playing.</p>\n          <p style={{ color: 'var(--text-muted)', fontSize: 8 }}>\n            Push boxes onto goals. All moves are verified on-chain.\n          </p>\n          <div className=\"connect-cta\">\n            <div className=\"pixel-connect-wrapper\">\n              <span className=\"pixel-connect-label\">â–¶ Connect & Play</span>\n              <div className=\"pixel-connect-real\">\n                <ConnectButton />\n              </div>\n            </div>\n          </div>\n        </div>\n      ) : screen === 'select' ? (\n        <LevelSelect\n          onLevelStarted={() => setScreen('play')}\n        />\n      ) : screen === 'play' ? (\n        <div className=\"game-container\">\n          {/* Stats bar */}\n          <div className=\"game-header\">\n            <div className=\"stat\">\n              <span className=\"stat-label\">Level</span>\n              <span className=\"stat-value\">{level?.id ?? '-'}</span>\n            </div>\n            <div className=\"stat-divider\" />\n            <div className=\"stat\">\n              <span className=\"stat-label\">Moves</span>\n              <span className=\"stat-value\">{moveQueue.length}</span>\n            </div>\n            <div className=\"stat-divider\" />\n            <div className=\"stat\">\n              <span className=\"stat-label\">Max</span>\n              <span className=\"stat-value\">{levelData?.maxMoves ?? '-'}</span>\n            </div>\n            {playerEntityId && (\n              <>\n                <div className=\"stat-divider\" />\n                <div className=\"stat\">\n                  <span className=\"stat-label\">Entities</span>\n                  <span className=\"stat-value\" style={{ fontSize: 12, color: 'var(--cell-box-on-goal)' }}>âœ“ Found</span>\n                </div>\n              </>\n            )}\n          </div>\n\n          <GameBoard />\n          <MoveControls />\n\n          {/* Submit / Back */}\n          <div className=\"action-bar\">\n            <button className=\"btn btn-secondary\" onClick={handleBackToSelect}>\n              â† Levels\n            </button>\n            {solved && (\n              <button\n                className=\"btn btn-primary\"\n                onClick={handleSubmit}\n                disabled={submitting}\n              >\n                {submitting ? (\n                  <>\n                    <div className=\"spinner\" style={{ width: 14, height: 14, borderWidth: 2 }} />\n                    Submitting...\n                  </>\n                ) : (\n                  'ğŸ¯ Submit Solution On-Chain'\n                )}\n              </button>\n            )}\n          </div>\n\n          {error && <div className=\"error-msg\">{error}</div>}\n        </div>\n      ) : (\n        /* Victory screen */\n        <div className=\"victory\">\n          <h2>ğŸ‰ Level Complete!</h2>\n          <p>All boxes are on their goals. Solution verified on-chain!</p>\n          <div className=\"stats\">\n            <div className=\"stat\">\n              <span className=\"stat-label\">Level</span>\n              <span className=\"stat-value\">{level?.name}</span>\n            </div>\n            <div className=\"stat-divider\" style={{ height: 40 }} />\n            <div className=\"stat\">\n              <span className=\"stat-label\">Moves Used</span>\n              <span className=\"stat-value\">{submitMoves}</span>\n            </div>\n          </div>\n          <div className=\"action-bar\" style={{ justifyContent: 'center' }}>\n            <button className=\"btn btn-primary\" onClick={handleBackToSelect}>\n              Play Another Level\n            </button>\n          </div>\n        </div>\n      )}\n    </>\n  );\n}\n\nexport default App;\n"
  },
  {
    "path": "frontend/src/index.css",
    "size": 16424,
    "content": "@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');\n\n:root {\n  /* Pixel art palette â€” earthy dungeon tones */\n  --bg-primary: #1a1020;\n  --bg-secondary: #251832;\n  --bg-card: #2a1e3a;\n  --bg-cell: #1e1e2a;\n  --bg-hover: #3a2850;\n\n  --accent: #b070ff;\n  --accent-glow: #b070ff30;\n  --accent-hover: #c898ff;\n\n  --pixel-green: #4ade80;\n  --pixel-gold: #fbbf24;\n  --pixel-red: #f87171;\n  --pixel-blue: #60a5fa;\n  --pixel-pink: #d06cff;\n\n  --text-primary: #e8e0f8;\n  --text-secondary: #9888b8;\n  --text-muted: #6a5888;\n\n  /* Pixel art borders */\n  --border-light: #ffffff12;\n  --border-accent: #b070ff50;\n\n  /* Cell colors (kept for compatibility) */\n  --cell-box-on-goal: #4ade80;\n  --cell-box-on-goal-glow: #4ade8040;\n\n  /* Difficulty */\n  --easy: #4ade80;\n  --medium: #fbbf24;\n  --hard: #f87171;\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: 'Press Start 2P', monospace;\n  background: var(--bg-primary);\n  color: var(--text-primary);\n  min-height: 100vh;\n  overflow-x: hidden;\n  image-rendering: pixelated;\n}\n\n/* Subtle pixel grid background */\nbody::before {\n  content: '';\n  position: fixed;\n  inset: 0;\n  background:\n    repeating-linear-gradient(0deg,   transparent 0px, transparent 3px, #ffffff03 3px, #ffffff03 4px),\n    repeating-linear-gradient(90deg,  transparent 0px, transparent 3px, #ffffff03 3px, #ffffff03 4px);\n  pointer-events: none;\n  z-index: 0;\n}\n\n#root {\n  position: relative;\n  z-index: 1;\n  min-height: 100vh;\n  display: flex;\n  flex-direction: column;\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* PIXEL BORDER UTILITY                */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* Chunky 3D pixel border effect      */\n\n.pixel-panel {\n  background: var(--bg-card);\n  border: 3px solid #5a4878;\n  border-top-color: #8a68c0;\n  border-left-color: #7858a8;\n  border-right-color: #3a2858;\n  border-bottom-color: #2a1848;\n  box-shadow:\n    inset 1px 1px 0 #ffffff10,\n    4px 4px 0 #0a0818;\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* HEADER                              */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n.header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 12px 20px;\n  background: var(--bg-secondary);\n  border-bottom: 3px solid #3a2858;\n  box-shadow: 0 4px 0 #0a0818;\n}\n\n.header-logo {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n}\n\n.header-logo h1 {\n  font-size: 14px;\n  font-weight: 400;\n  color: var(--pixel-pink);\n  text-shadow: 2px 2px 0 #2a1040;\n  letter-spacing: 2px;\n}\n\n.header-logo .emoji {\n  font-size: 20px;\n}\n\n.header-info {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n}\n\n.header-badge {\n  font-size: 8px;\n  padding: 4px 8px;\n  background: #b070ff20;\n  color: var(--accent);\n  border: 2px solid #b070ff40;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* LEVEL SELECT                        */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n.level-select {\n  max-width: 720px;\n  margin: 0 auto;\n  padding: 40px 20px;\n}\n\n.level-select h2 {\n  text-align: center;\n  font-size: 16px;\n  color: var(--pixel-gold);\n  text-shadow: 2px 2px 0 #3a2000;\n  margin-bottom: 8px;\n  letter-spacing: 2px;\n}\n\n.level-select .subtitle {\n  text-align: center;\n  color: var(--text-secondary);\n  margin-bottom: 32px;\n  font-size: 8px;\n  line-height: 1.8;\n}\n\n.level-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));\n  gap: 16px;\n}\n\n.level-card {\n  background: var(--bg-card);\n  border: 3px solid #5a4878;\n  border-top-color: #8a68c0;\n  border-left-color: #7858a8;\n  border-right-color: #3a2858;\n  border-bottom-color: #2a1848;\n  box-shadow: 4px 4px 0 #0a0818;\n  padding: 20px;\n  cursor: pointer;\n  transition: transform 0.1s, box-shadow 0.1s;\n  position: relative;\n}\n\n.level-card:hover {\n  transform: translate(-2px, -2px);\n  box-shadow: 6px 6px 0 #0a0818;\n  border-top-color: var(--accent);\n  border-left-color: var(--accent);\n}\n\n.level-card:active {\n  transform: translate(2px, 2px);\n  box-shadow: 2px 2px 0 #0a0818;\n}\n\n.level-card .level-number {\n  font-size: 8px;\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 2px;\n  margin-bottom: 8px;\n}\n\n.level-card .level-name {\n  font-size: 12px;\n  color: var(--pixel-gold);\n  text-shadow: 1px 1px 0 #3a2000;\n  margin-bottom: 14px;\n}\n\n.level-card .level-meta {\n  display: flex;\n  gap: 6px;\n  flex-wrap: wrap;\n}\n\n.level-card .tag {\n  font-size: 7px;\n  padding: 3px 6px;\n  border: 2px solid;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n}\n\n.tag.easy { border-color: #4ade8040; color: var(--easy); background: #4ade8010; }\n.tag.medium { border-color: #fbbf2440; color: var(--medium); background: #fbbf2410; }\n.tag.hard { border-color: #f8717140; color: var(--hard); background: #f8717110; }\n.tag.info { border-color: #ffffff15; color: var(--text-secondary); background: #ffffff05; }\n\n.level-card.disabled {\n  opacity: 0.35;\n  pointer-events: none;\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* GAME AREA                           */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n.game-container {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  padding: 24px 20px;\n  gap: 20px;\n  flex: 1;\n}\n\n.game-header {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  flex-wrap: wrap;\n  justify-content: center;\n}\n\n.stat {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 4px;\n}\n\n.stat-label {\n  font-size: 7px;\n  text-transform: uppercase;\n  letter-spacing: 2px;\n  color: var(--text-muted);\n}\n\n.stat-value {\n  font-size: 16px;\n  color: var(--accent);\n  text-shadow: 1px 1px 0 #2a1040;\n}\n\n.stat-divider {\n  width: 2px;\n  height: 28px;\n  background: #5a4878;\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* GAME BOARD (Canvas)                 */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n.board {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 8px;\n  background: var(--bg-secondary);\n  border: 3px solid #5a4878;\n  border-top-color: #8a68c0;\n  border-left-color: #7858a8;\n  border-right-color: #3a2858;\n  border-bottom-color: #2a1848;\n  box-shadow: 4px 4px 0 #0a0818;\n}\n\n.game-canvas {\n  image-rendering: pixelated;\n  image-rendering: crisp-edges;\n  width: min(384px, 85vw);\n  height: auto;\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* CONTROLS                            */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n.controls {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 14px;\n}\n\n/* Move queue */\n.move-queue {\n  display: flex;\n  gap: 3px;\n  flex-wrap: wrap;\n  justify-content: center;\n  max-width: 400px;\n  min-height: 24px;\n}\n\n.move-arrow {\n  font-size: 10px;\n  width: 22px;\n  height: 22px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--bg-card);\n  border: 2px solid #5a4878;\n  color: var(--text-secondary);\n}\n\n.move-arrow:last-child {\n  color: var(--accent);\n  border-color: var(--accent);\n  background: #b070ff15;\n}\n\n/* D-pad */\n.dpad {\n  display: grid;\n  grid-template-columns: repeat(3, 44px);\n  grid-template-rows: repeat(3, 44px);\n  gap: 3px;\n}\n\n.dpad-btn {\n  background: var(--bg-card);\n  border: 3px solid #5a4878;\n  border-top-color: #8a68c0;\n  border-left-color: #7858a8;\n  border-right-color: #3a2858;\n  border-bottom-color: #2a1848;\n  color: var(--text-primary);\n  font-family: 'Press Start 2P', monospace;\n  font-size: 14px;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: transform 0.05s, box-shadow 0.05s;\n  box-shadow: 2px 2px 0 #0a0818;\n}\n\n.dpad-btn:hover {\n  border-top-color: var(--accent);\n  border-left-color: var(--accent);\n  color: var(--accent);\n}\n\n.dpad-btn:active {\n  transform: translate(2px, 2px);\n  box-shadow: 0 0 0 #0a0818;\n  border-top-color: #3a2858;\n  border-left-color: #3a2858;\n  border-right-color: #8a68c0;\n  border-bottom-color: #7858a8;\n}\n\n.dpad-btn.empty {\n  visibility: hidden;\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* BUTTONS                             */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n.action-bar {\n  display: flex;\n  gap: 8px;\n  flex-wrap: wrap;\n  justify-content: center;\n}\n\n.btn {\n  font-family: 'Press Start 2P', monospace;\n  font-size: 8px;\n  padding: 10px 16px;\n  border: 3px solid;\n  cursor: pointer;\n  transition: transform 0.05s, box-shadow 0.05s;\n  display: flex;\n  align-items: center;\n  gap: 6px;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  line-height: 1.4;\n}\n\n.btn-primary {\n  background: var(--accent);\n  color: white;\n  border-top-color: #c898ff;\n  border-left-color: #b070ff;\n  border-right-color: #6030a0;\n  border-bottom-color: #402080;\n  box-shadow: 3px 3px 0 #0a0818;\n  text-shadow: 1px 1px 0 #4020a0;\n}\n\n.btn-primary:hover:not(:disabled) {\n  transform: translate(-1px, -1px);\n  box-shadow: 4px 4px 0 #0a0818;\n}\n\n.btn-primary:active:not(:disabled) {\n  transform: translate(2px, 2px);\n  box-shadow: 1px 1px 0 #0a0818;\n}\n\n.btn-secondary {\n  background: var(--bg-card);\n  color: var(--text-primary);\n  border-top-color: #8a68c0;\n  border-left-color: #7858a8;\n  border-right-color: #3a2858;\n  border-bottom-color: #2a1848;\n  box-shadow: 3px 3px 0 #0a0818;\n}\n\n.btn-secondary:hover:not(:disabled) {\n  color: var(--accent);\n  transform: translate(-1px, -1px);\n  box-shadow: 4px 4px 0 #0a0818;\n}\n\n.btn-secondary:active:not(:disabled) {\n  transform: translate(2px, 2px);\n  box-shadow: 1px 1px 0 #0a0818;\n}\n\n.btn-danger {\n  background: #381820;\n  color: var(--pixel-red);\n  border-top-color: #884040;\n  border-left-color: #703030;\n  border-right-color: #301010;\n  border-bottom-color: #200808;\n  box-shadow: 3px 3px 0 #0a0818;\n}\n\n.btn-danger:hover:not(:disabled) {\n  transform: translate(-1px, -1px);\n  box-shadow: 4px 4px 0 #0a0818;\n}\n\n.btn-danger:active:not(:disabled) {\n  transform: translate(2px, 2px);\n  box-shadow: 1px 1px 0 #0a0818;\n}\n\n.btn:disabled {\n  opacity: 0.3;\n  cursor: not-allowed;\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* VICTORY SCREEN                      */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n.victory {\n  text-align: center;\n  padding: 48px 20px;\n  max-width: 480px;\n  margin: 0 auto;\n}\n\n.victory h2 {\n  font-size: 18px;\n  color: var(--pixel-gold);\n  text-shadow: 2px 2px 0 #3a2000;\n  margin-bottom: 12px;\n  letter-spacing: 2px;\n  animation: victory-bounce 0.6s ease-out;\n}\n\n.victory p {\n  color: var(--text-secondary);\n  font-size: 8px;\n  line-height: 2;\n  margin-bottom: 28px;\n}\n\n.victory .stats {\n  display: flex;\n  gap: 24px;\n  justify-content: center;\n  margin-bottom: 28px;\n  padding: 16px;\n  background: var(--bg-card);\n  border: 3px solid #5a4878;\n  border-top-color: #8a68c0;\n  border-left-color: #7858a8;\n  border-right-color: #3a2858;\n  border-bottom-color: #2a1848;\n  box-shadow: 4px 4px 0 #0a0818;\n}\n\n@keyframes victory-bounce {\n  0% { transform: scale(0.5); opacity: 0; }\n  50% { transform: scale(1.1); }\n  100% { transform: scale(1); opacity: 1; }\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* LOADING & ERROR                     */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n.loading {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  min-height: 60vh;\n  color: var(--text-secondary);\n  font-size: 8px;\n}\n\n.spinner {\n  width: 16px;\n  height: 16px;\n  border: 3px solid #b070ff30;\n  border-top-color: var(--accent);\n  animation: spin 0.8s steps(8) infinite;\n  margin-right: 10px;\n}\n\n@keyframes spin {\n  to { transform: rotate(360deg); }\n}\n\n.error-msg {\n  background: #381820;\n  color: var(--pixel-red);\n  padding: 10px 14px;\n  border: 2px solid #703030;\n  font-size: 8px;\n  text-align: center;\n  max-width: 360px;\n  line-height: 1.8;\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* CONNECT PROMPT                      */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n.connect-prompt {\n  text-align: center;\n  padding: 80px 20px;\n}\n\n.connect-prompt h2 {\n  font-size: 16px;\n  color: var(--pixel-gold);\n  text-shadow: 2px 2px 0 #3a2000;\n  margin-bottom: 12px;\n  letter-spacing: 2px;\n}\n\n.connect-prompt p {\n  color: var(--text-secondary);\n  margin-bottom: 20px;\n  font-size: 8px;\n  line-height: 2;\n}\n\n.hero-sprite {\n  margin-bottom: 24px;\n}\n\n.connect-cta {\n  margin-top: 8px;\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* SUI CONNECT BUTTON â€” PIXEL WRAPPER  */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n.pixel-connect-wrapper {\n  position: relative;\n  display: inline-block;\n  background: var(--accent);\n  border: 3px solid;\n  border-top-color: #c898ff;\n  border-left-color: #b070ff;\n  border-right-color: #6030a0;\n  border-bottom-color: #402080;\n  box-shadow: 3px 3px 0 #0a0818;\n  cursor: pointer;\n  transition: transform 0.05s, box-shadow 0.05s;\n}\n\n.pixel-connect-wrapper:hover {\n  transform: translate(-1px, -1px);\n  box-shadow: 4px 4px 0 #0a0818;\n}\n\n.pixel-connect-wrapper:active {\n  transform: translate(2px, 2px);\n  box-shadow: 1px 1px 0 #0a0818;\n}\n\n.pixel-connect-label {\n  display: block;\n  font-family: 'Press Start 2P', monospace;\n  font-size: 10px;\n  color: white;\n  text-shadow: 1px 1px 0 #4020a0;\n  padding: 12px 24px;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  pointer-events: none;\n}\n\n.pixel-connect-real {\n  position: absolute;\n  inset: 0;\n  opacity: 0;\n  overflow: hidden;\n}\n\n.pixel-connect-real mysten-dapp-kit-connect-button,\n.pixel-connect-real button {\n  width: 100% !important;\n  height: 100% !important;\n  cursor: pointer !important;\n}\n\n/* Header connect button â€” keep smaller, semi-transparent overlay */\n.header .pixel-connect-wrapper {\n  box-shadow: 2px 2px 0 #0a0818;\n}\n\n.header .pixel-connect-label {\n  font-size: 7px;\n  padding: 8px 14px;\n}\n\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n/* RESPONSIVE                          */\n/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n@media (max-width: 480px) {\n  .board {\n    padding: 6px;\n  }\n\n  .dpad {\n    grid-template-columns: repeat(3, 40px);\n    grid-template-rows: repeat(3, 40px);\n  }\n\n  .header {\n    padding: 10px 12px;\n  }\n\n  .header-logo h1 {\n    font-size: 10px;\n  }\n\n  .game-header {\n    gap: 12px;\n  }\n\n  .stat-value {\n    font-size: 12px;\n  }\n\n  .level-select h2 {\n    font-size: 12px;\n  }\n}\n\n/* Keyboard hint */\n.keyboard-hint {\n  font-size: 7px;\n  color: var(--text-muted);\n  text-align: center;\n  line-height: 2;\n}\n\nkbd {\n  font-family: 'Press Start 2P', monospace;\n  background: var(--bg-card);\n  border: 2px solid #5a4878;\n  border-bottom-color: #2a1848;\n  padding: 2px 5px;\n  font-size: 7px;\n  color: var(--text-secondary);\n}\n\n/* Move counter text */\n.move-counter {\n  font-size: 8px;\n  color: var(--text-secondary);\n}\n\n.move-counter .solved {\n  color: var(--pixel-green);\n}\n\n@keyframes pulse-glow {\n  0%, 100% { box-shadow: 0 2px 12px var(--cell-box-on-goal-glow); }\n  50% { box-shadow: 0 2px 24px var(--cell-box-on-goal-glow), 0 0 40px var(--cell-box-on-goal-glow); }\n}\n"
  },
  {
    "path": "frontend/src/constants.ts",
    "size": 3302,
    "content": "// Deployed contract IDs (testnet) â€” v4 per-player sessions\nexport const PACKAGE_ID = '0xc77ba0bedb78364d08fe6f310bc500236df7ec8bc9a0d83f260ef835f5405c6e';\n// GAME_SESSION_ID and GRID_ID are now dynamic â€” created per start_level call\nexport const WORLD_ID = '0xd58bee2ebe4ccd5216f8adb8e7ac437e25c017a3fa42e71ceb9b83a75f0f0ea2';\nexport const CLOCK_ID = '0x6';\nexport const ENTITY_PACKAGE_ID = '0x5027c19c807223b4b91e8f70b694c5b37118d5ea727d982820b837b54697d7f4';\n\n// Direction constants (match Move contract)\nexport const DIR_UP = 0;\nexport const DIR_RIGHT = 1;\nexport const DIR_DOWN = 2;\nexport const DIR_LEFT = 3;\n\n// Marker types\nexport const MARKER_PLAYER = 0;\nexport const MARKER_WALL = 1;\nexport const MARKER_BOX = 2;\n\n// Game states\nexport const STATE_LOBBY = 0;\nexport const STATE_ACTIVE = 1;\nexport const STATE_FINISHED = 2;\n\n// Grid size\nexport const GRID_W = 6;\nexport const GRID_H = 6;\n\n// Level metadata\nexport const LEVELS = [\n    { id: 1, name: 'First Steps', boxes: 2, difficulty: 'Easy', maxMoves: 12 },\n    { id: 2, name: 'Open Field', boxes: 2, difficulty: 'Easy', maxMoves: 16 },\n    { id: 3, name: 'Storage Room', boxes: 3, difficulty: 'Medium', maxMoves: 14 },\n    { id: 4, name: 'Crossroads', boxes: 2, difficulty: 'Medium', maxMoves: 14 },\n    { id: 5, name: 'The Gauntlet', boxes: 3, difficulty: 'Hard', maxMoves: 20 },\n];\n\n// Level data for client-side simulation (mirrors Move contract)\nexport interface LevelData {\n    wallXs: number[]; wallYs: number[];\n    boxXs: number[]; boxYs: number[];\n    goalXs: number[]; goalYs: number[];\n    playerX: number; playerY: number;\n    maxMoves: number;\n}\n\nexport function getLevelData(levelId: number): LevelData {\n    switch (levelId) {\n        case 1: return {\n            wallXs: [1, 2, 3, 4], wallYs: [1, 1, 1, 1],\n            boxXs: [2, 3], boxYs: [3, 3],\n            goalXs: [4, 4], goalYs: [2, 3],\n            playerX: 3, playerY: 4, maxMoves: 12,\n        };\n        case 2: return {\n            wallXs: [2], wallYs: [3],\n            boxXs: [3, 3], boxYs: [2, 4],\n            goalXs: [1, 1], goalYs: [2, 4],\n            playerX: 3, playerY: 5, maxMoves: 16,\n        };\n        case 3: return {\n            wallXs: [2, 3, 4], wallYs: [1, 1, 1],\n            boxXs: [2, 2, 2], boxYs: [3, 4, 5],\n            goalXs: [1, 1, 1], goalYs: [3, 4, 5],\n            playerX: 3, playerY: 5, maxMoves: 14,\n        };\n        case 4: return {\n            wallXs: [3, 3], wallYs: [1, 5],\n            boxXs: [3, 2], boxYs: [2, 4],\n            goalXs: [1, 4], goalYs: [2, 4],\n            playerX: 2, playerY: 5, maxMoves: 14,\n        };\n        case 5: return {\n            wallXs: [1, 3, 1, 3], wallYs: [1, 1, 5, 5],\n            boxXs: [2, 2, 2], boxYs: [2, 3, 4],\n            goalXs: [4, 0, 4], goalYs: [2, 3, 4],\n            playerX: 2, playerY: 5, maxMoves: 20,\n        };\n        default: throw new Error(`Invalid level: ${levelId}`);\n    }\n}\n\n// Error code mapping\nexport const ERROR_MAP: Record<number, string> = {\n    100: 'Invalid game state',\n    101: 'Not the player',\n    102: 'Invalid direction',\n    103: 'Too many moves',\n    104: 'Blocked by wall',\n    105: 'Out of bounds',\n    106: 'Blocked by another box',\n    107: 'Puzzle not solved',\n    108: 'Invalid level',\n    109: 'Already started',\n    110: 'Level not active',\n};\n"
  },
  {
    "path": "frontend/src/dApp-kit.ts",
    "size": 616,
    "content": "import { createDAppKit } from '@mysten/dapp-kit-core';\nimport { SuiGrpcClient } from '@mysten/sui/grpc';\n\nconst GRPC_URLS = {\n    testnet: 'https://fullnode.testnet.sui.io:443',\n    devnet: 'https://fullnode.devnet.sui.io:443',\n} as const;\n\nexport const dAppKit = createDAppKit({\n    networks: ['testnet', 'devnet'],\n    defaultNetwork: 'testnet',\n    enableBurnerWallet: import.meta.env.DEV,\n    createClient(network) {\n        return new SuiGrpcClient({ network, baseUrl: GRPC_URLS[network] });\n    },\n});\n\ndeclare module '@mysten/dapp-kit-core' {\n    interface Register {\n        dAppKit: typeof dAppKit;\n    }\n}\n"
  },
  {
    "path": "frontend/src/lib/suiClient.ts",
    "size": 199,
    "content": "import { SuiJsonRpcClient, getJsonRpcFullnodeUrl } from '@mysten/sui/jsonRpc';\n\nexport const suiClient = new SuiJsonRpcClient({\n    network: 'testnet',\n    url: getJsonRpcFullnodeUrl('testnet'),\n});\n"
  },
  {
    "path": "frontend/src/stores/gameStore.ts",
    "size": 6528,
    "content": "import { create } from 'zustand';\nimport {\n    GRID_W, GRID_H, DIR_UP, DIR_RIGHT, DIR_DOWN, DIR_LEFT,\n    getLevelData, type LevelData,\n} from '../constants';\n\n// Cell types for rendering\nexport type CellType = 'empty' | 'wall' | 'box' | 'player' | 'box_on_goal' | 'player_on_goal';\n\ninterface GameStore {\n    // Level state\n    levelId: number | null;\n    levelData: LevelData | null;\n\n    // On-chain object IDs (per-player session)\n    sessionId: string | null;\n    gridId: string | null;\n    playerEntityId: string | null;\n    boxEntityIds: string[];\n\n    // Simulated board\n    playerPos: { x: number; y: number } | null;\n    boxPositions: { x: number; y: number }[];\n    moveQueue: number[];\n\n    // Actions\n    initLevel: (levelId: number, sessionId: string, gridId: string, playerEntityId: string, boxEntityIds: string[]) => void;\n    addMove: (dir: number) => boolean;\n    undoMove: () => void;\n    resetMoves: () => void;\n    getDirectionName: (dir: number) => string;\n    getCellType: (x: number, y: number) => CellType;\n    isGoal: (x: number, y: number) => boolean;\n    isSolved: () => boolean;\n}\n\nexport const useGameStore = create<GameStore>((set, get) => ({\n    levelId: null,\n    levelData: null,\n    sessionId: null,\n    gridId: null,\n    playerEntityId: null,\n    boxEntityIds: [],\n    playerPos: null,\n    boxPositions: [],\n    moveQueue: [],\n\n    initLevel: (levelId: number, sessionId: string, gridId: string, playerEntityId: string, boxEntityIds: string[]) => {\n        const data = getLevelData(levelId);\n        set({\n            levelId,\n            levelData: data,\n            sessionId,\n            gridId,\n            playerEntityId,\n            boxEntityIds,\n            playerPos: { x: data.playerX, y: data.playerY },\n            boxPositions: data.boxXs.map((x, i) => ({ x, y: data.boxYs[i] })),\n            moveQueue: [],\n        });\n    },\n\n    addMove: (dir: number) => {\n        const { playerPos, boxPositions, levelData, moveQueue } = get();\n        if (!playerPos || !levelData) return false;\n        if (moveQueue.length >= levelData.maxMoves) return false;\n\n        const target = calcTarget(playerPos.x, playerPos.y, dir);\n        if (!target) return false;\n\n        // Check wall\n        if (isWall(levelData, target.x, target.y)) return false;\n\n        // Check box\n        const boxIdx = boxPositions.findIndex(b => b.x === target.x && b.y === target.y);\n        if (boxIdx >= 0) {\n            // Try to push box\n            const pushTarget = calcTarget(target.x, target.y, dir);\n            if (!pushTarget) return false;\n            if (isWall(levelData, pushTarget.x, pushTarget.y)) return false;\n            if (boxPositions.some(b => b.x === pushTarget.x && b.y === pushTarget.y)) return false;\n\n            // Push box\n            const newBoxes = [...boxPositions];\n            newBoxes[boxIdx] = { x: pushTarget.x, y: pushTarget.y };\n            set({\n                playerPos: { x: target.x, y: target.y },\n                boxPositions: newBoxes,\n                moveQueue: [...moveQueue, dir],\n            });\n            return true;\n        }\n\n        // Just move player\n        set({\n            playerPos: { x: target.x, y: target.y },\n            moveQueue: [...moveQueue, dir],\n        });\n        return true;\n    },\n\n    undoMove: () => {\n        const { moveQueue, levelData, levelId } = get();\n        if (!moveQueue.length || !levelData || !levelId) return;\n\n        // Replay from start minus last move\n        const newQueue = moveQueue.slice(0, -1);\n        const data = getLevelData(levelId);\n        let px = data.playerX;\n        let py = data.playerY;\n        let boxes = data.boxXs.map((x, i) => ({ x, y: data.boxYs[i] }));\n\n        for (const dir of newQueue) {\n            const target = calcTarget(px, py, dir)!;\n            const boxIdx = boxes.findIndex(b => b.x === target.x && b.y === target.y);\n            if (boxIdx >= 0) {\n                const push = calcTarget(target.x, target.y, dir)!;\n                boxes = [...boxes];\n                boxes[boxIdx] = { x: push.x, y: push.y };\n            }\n            px = target.x;\n            py = target.y;\n        }\n\n        set({\n            playerPos: { x: px, y: py },\n            boxPositions: boxes,\n            moveQueue: newQueue,\n        });\n    },\n\n    resetMoves: () => {\n        const { levelId, sessionId, gridId, playerEntityId, boxEntityIds } = get();\n        if (!levelId) return;\n        get().initLevel(levelId, sessionId ?? '', gridId ?? '', playerEntityId ?? '', boxEntityIds);\n    },\n\n    getDirectionName: (dir: number) => {\n        switch (dir) {\n            case DIR_UP: return 'â†‘';\n            case DIR_RIGHT: return 'â†’';\n            case DIR_DOWN: return 'â†“';\n            case DIR_LEFT: return 'â†';\n            default: return '?';\n        }\n    },\n\n    getCellType: (x: number, y: number) => {\n        const { playerPos, boxPositions, levelData } = get();\n        if (!levelData) return 'empty';\n\n        if (playerPos && playerPos.x === x && playerPos.y === y) {\n            return isGoalAt(levelData, x, y) ? 'player_on_goal' : 'player';\n        }\n        if (boxPositions.some(b => b.x === x && b.y === y)) {\n            return isGoalAt(levelData, x, y) ? 'box_on_goal' : 'box';\n        }\n        if (isWall(levelData, x, y)) return 'wall';\n        return 'empty';\n    },\n\n    isGoal: (x: number, y: number) => {\n        const { levelData } = get();\n        if (!levelData) return false;\n        return isGoalAt(levelData, x, y);\n    },\n\n    isSolved: () => {\n        const { levelData, boxPositions } = get();\n        if (!levelData) return false;\n        return levelData.goalXs.every((gx, i) => {\n            const gy = levelData.goalYs[i];\n            return boxPositions.some(b => b.x === gx && b.y === gy);\n        });\n    },\n}));\n\n// Helpers\nfunction calcTarget(x: number, y: number, dir: number): { x: number; y: number } | null {\n    switch (dir) {\n        case DIR_UP: return y === 0 ? null : { x, y: y - 1 };\n        case DIR_RIGHT: return x + 1 >= GRID_W ? null : { x: x + 1, y };\n        case DIR_DOWN: return y + 1 >= GRID_H ? null : { x, y: y + 1 };\n        case DIR_LEFT: return x === 0 ? null : { x: x - 1, y };\n        default: return null;\n    }\n}\n\nfunction isWall(data: LevelData, x: number, y: number): boolean {\n    return data.wallXs.some((wx, i) => wx === x && data.wallYs[i] === y);\n}\n\nfunction isGoalAt(data: LevelData, x: number, y: number): boolean {\n    return data.goalXs.some((gx, i) => gx === x && data.goalYs[i] === y);\n}\n"
  },
  {
    "path": "frontend/src/hooks/useGameActions.ts",
    "size": 8457,
    "content": "import { Transaction } from '@mysten/sui/transactions';\nimport { useDAppKit, useCurrentClient } from '@mysten/dapp-kit-react';\nimport { suiClient } from '../lib/suiClient';\nimport {\n    PACKAGE_ID, WORLD_ID, CLOCK_ID,\n    ENTITY_PACKAGE_ID, ERROR_MAP, getLevelData, GRID_W,\n} from '../constants';\n\nfunction parseTransactionError(failure: { error: string }): Error {\n    const match = failure.error.match(/MoveAbort.*?(\\d+)\\)?$/);\n    if (match) {\n        const code = Number(match[1]);\n        const message = ERROR_MAP[code] ?? `Transaction failed (code ${code})`;\n        return new Error(message);\n    }\n    return new Error(failure.error || 'Transaction failed');\n}\n\nexport function useGameActions() {\n    const dAppKit = useDAppKit();\n    const client = useCurrentClient();\n\n    return {\n        startLevel: async (levelId: number) => {\n            const tx = new Transaction();\n            tx.moveCall({\n                package: PACKAGE_ID,\n                module: 'game',\n                function: 'start_level',\n                arguments: [\n                    tx.object(WORLD_ID),\n                    tx.pure.u64(levelId),\n                    tx.object(CLOCK_ID),\n                ],\n            });\n\n            const result = await dAppKit.signAndExecuteTransaction({ transaction: tx });\n            if (result.$kind === 'FailedTransaction') {\n                throw parseTransactionError(result.FailedTransaction as any);\n            }\n\n            // Wait for finality\n            await client.waitForTransaction({\n                digest: result.Transaction.digest,\n            });\n\n            // Fetch full transaction details with events\n            const txResponse = await suiClient.getTransactionBlock({\n                digest: result.Transaction.digest,\n                options: { showEvents: true, showObjectChanges: true },\n            });\n\n            // Discover the newly created GameSession and Grid from transaction events\n            const { sessionId, gridId } = discoverCreatedObjects(txResponse);\n\n            // Discover entities by querying the new Grid's Table for known positions\n            const { playerEntityId, boxEntityIds } = await discoverEntitiesFromGrid(gridId, levelId);\n\n            return { playerEntityId, boxEntityIds, sessionId, gridId };\n        },\n\n        submitSolution: async (\n            directions: number[],\n            playerEntityId: string,\n            boxEntityIds: string[],\n            sessionId: string,\n            gridId: string,\n        ) => {\n            const tx = new Transaction();\n\n            // Build the box entity vector\n            const boxObjects = boxEntityIds.map(id => tx.object(id));\n            const boxVec = tx.makeMoveVec({\n                type: `${ENTITY_PACKAGE_ID}::entity::Entity`,\n                elements: boxObjects,\n            });\n\n            tx.moveCall({\n                package: PACKAGE_ID,\n                module: 'game',\n                function: 'submit_solution',\n                arguments: [\n                    tx.object(sessionId),\n                    tx.object(WORLD_ID),\n                    tx.object(gridId),\n                    tx.object(playerEntityId),\n                    boxVec,\n                    tx.pure.vector('u8', directions),\n                ],\n            });\n\n            const result = await dAppKit.signAndExecuteTransaction({ transaction: tx });\n            if (result.$kind === 'FailedTransaction') {\n                throw parseTransactionError(result.FailedTransaction as any);\n            }\n\n            await client.waitForTransaction({\n                digest: result.Transaction.digest,\n                include: { effects: true },\n            });\n\n            return result.Transaction;\n        },\n    };\n}\n\n/**\n * Parse transaction effects to find the newly created GameSession and Grid objects.\n * GameSession type: `${PACKAGE_ID}::game::GameSession`\n * Grid type: from the systems package `grid_sys::Grid`\n */\nfunction discoverCreatedObjects(txResponse: any): { sessionId: string; gridId: string } {\n    let sessionId = '';\n    let gridId = '';\n\n    console.log('[ObjectDiscovery] Full txResponse keys:', Object.keys(txResponse));\n\n    // Primary: read from LevelStarted event\n    const events = txResponse.events ?? [];\n    console.log(`[ObjectDiscovery] Events found: ${events.length}`);\n    for (const event of events) {\n        console.log(`[ObjectDiscovery] Event type: ${event.type}`);\n        if (event.type?.includes('::game::LevelStarted')) {\n            const parsed = event.parsedJson;\n            console.log(`[ObjectDiscovery] LevelStarted parsed:`, parsed);\n            sessionId = parsed?.session_id ?? '';\n            gridId = parsed?.grid_id ?? '';\n            break;\n        }\n    }\n\n    // Fallback: parse from objectChanges if events didn't work\n    if (!sessionId || !gridId) {\n        const changes = txResponse.objectChanges ?? [];\n        console.log(`[ObjectDiscovery] Falling back to objectChanges: ${changes.length}`);\n        for (const change of changes) {\n            console.log(`[ObjectDiscovery] Change: type=${change.type}, objectType=${change.objectType}`);\n            if (change.type === 'created') {\n                if (change.objectType?.includes('::game::GameSession')) {\n                    sessionId = change.objectId;\n                    console.log(`[ObjectDiscovery] Found GameSession: ${sessionId}`);\n                } else if (change.objectType?.includes('::grid_sys::Grid')) {\n                    gridId = change.objectId;\n                    console.log(`[ObjectDiscovery] Found Grid: ${gridId}`);\n                }\n            }\n        }\n    }\n\n    if (!sessionId || !gridId) {\n        throw new Error('Could not discover session and grid IDs from transaction. ' +\n            `Events: ${events.length}, ObjectChanges: ${(txResponse.objectChanges ?? []).length}`);\n    }\n\n    console.log(`[ObjectDiscovery] Session: ${sessionId}, Grid: ${gridId}`);\n    return { sessionId, gridId };\n}\n\n/**\n * Discover player and box entities by reading the Grid's Table.\n *\n * Grid structure:\n *   Grid { cells: Table<u64, ID>, ... }\n *   Table entries are dynamic fields on the Table's own UID.\n *   Key = y * GRID_W + x (u64), Value = entity object ID.\n *\n * Steps:\n *   1. Read Grid object â†’ extract Table UID from cells.id.id\n *   2. For each needed position, use getDynamicFieldObject on the Table\n */\nasync function discoverEntitiesFromGrid(gridId: string, levelId: number) {\n    const levelData = getLevelData(levelId);\n\n    // Step 1: Read Grid to get the Table's internal UID\n    const gridObj = await suiClient.getObject({\n        id: gridId,\n        options: { showContent: true },\n    });\n\n    const gridFields = (gridObj.data?.content as any)?.fields;\n    const tableId = gridFields?.cells?.fields?.id?.id;\n\n    if (!tableId) {\n        throw new Error('Could not read Grid cells table ID');\n    }\n\n    console.log(`[EntityDiscovery] Grid Table ID: ${tableId}`);\n\n    // Step 2: Look up each needed position via getDynamicFieldObject\n    const playerPosIndex = levelData.playerY * GRID_W + levelData.playerX;\n    const boxPosIndices = levelData.boxXs.map((bx, i) => levelData.boxYs[i] * GRID_W + bx);\n\n    const allPositions = [playerPosIndex, ...boxPosIndices];\n\n    // Fetch all positions in parallel\n    const results = await Promise.all(\n        allPositions.map(async (posIndex) => {\n            try {\n                const field = await suiClient.getDynamicFieldObject({\n                    parentId: tableId,\n                    name: { type: 'u64', value: String(posIndex) },\n                });\n                const entityId = (field.data?.content as any)?.fields?.value;\n                return { posIndex, entityId: entityId ? String(entityId) : '' };\n            } catch (e) {\n                console.warn(`[EntityDiscovery] No entity at position ${posIndex}:`, e);\n                return { posIndex, entityId: '' };\n            }\n        })\n    );\n\n    const playerEntityId = results[0].entityId;\n    const boxEntityIds = results.slice(1).map(r => r.entityId);\n\n    console.log(`[EntityDiscovery] Player: ${playerEntityId}`);\n    console.log(`[EntityDiscovery] Boxes: ${boxEntityIds.join(', ')}`);\n\n    if (!playerEntityId) {\n        throw new Error('Could not find player entity on grid');\n    }\n    if (boxEntityIds.some(id => !id)) {\n        throw new Error('Could not find all box entities on grid');\n    }\n\n    return { playerEntityId, boxEntityIds };\n}\n"
  },
  {
    "path": "frontend/src/hooks/useGameState.ts",
    "size": 667,
    "content": "import { useGameStore } from '../stores/gameStore';\n\n/**\n * useGameState is no longer needed for fetching on-chain GameSession data\n * since sessions are now per-player (created dynamically per start_level call).\n *\n * The game store already tracks all state locally.\n * This hook is kept for convenience to re-export store data.\n */\nexport function useGameState() {\n    const sessionId = useGameStore((s) => s.sessionId);\n    const levelId = useGameStore((s) => s.levelId);\n    const levelData = useGameStore((s) => s.levelData);\n\n    return {\n        sessionId,\n        levelId,\n        levelData,\n        isActive: levelId !== null && sessionId !== null,\n    };\n}\n"
  },
  {
    "path": "frontend/src/utils/tileMap.ts",
    "size": 1946,
    "content": "/**\n * Tile map for the Sokoban tileset.\n * Spritesheet: tileset.png (5Ã—5 grid, 16Ã—16px per tile, 80Ã—80px total)\n */\n\nexport const TILE_SIZE = 16; // px in the source spritesheet\nexport const SHEET_COLS = 5;\n\n/** Tile positions as (row, col) in the 5Ã—5 grid */\nexport const TILES = {\n    WALL_TOP: { row: 0, col: 0 }, // tile 0  â€” wall (top face)\n    WALL: { row: 0, col: 1 }, // tile 1  â€” wall (default)\n    WALL_CORNER: { row: 0, col: 2 }, // tile 2  â€” left corner wall\n    GOAL: { row: 0, col: 3 }, // tile 3  â€” goal marker\n    GROUND: { row: 1, col: 0 }, // tile 5  â€” ground\n    GROUND_ALT: { row: 1, col: 1 }, // tile 6  â€” ground variation\n    WALL_SIDE: { row: 1, col: 2 }, // tile 7  â€” left-side wall\n    WATER: { row: 2, col: 0 }, // tile 10 â€” water (impassable)\n    BOX: { row: 4, col: 0 }, // tile 20 â€” box\n} as const;\n\nexport type TileKey = keyof typeof TILES;\n\n/** Get source x/y in the spritesheet for a given tile */\nexport function getTileSrc(tile: { row: number; col: number }) {\n    return {\n        sx: tile.col * TILE_SIZE,\n        sy: tile.row * TILE_SIZE,\n    };\n}\n\n/**\n * Determine which wall tile variant to use based on neighbors.\n * wallSet: Set of \"x,y\" strings for all wall positions.\n */\nexport function pickWallTile(\n    x: number, y: number,\n    wallSet: Set<string>,\n): { row: number; col: number } {\n    const above = wallSet.has(`${x},${y - 1}`);\n    const left = wallSet.has(`${x - 1},${y}`);\n\n    // Corner: no wall above AND no wall to the left\n    if (!above && !left) return TILES.WALL_CORNER;\n    // Top face: no wall above\n    if (!above) return TILES.WALL_TOP;\n    // Side: no wall to the left\n    if (!left) return TILES.WALL_SIDE;\n    // Default inner wall\n    return TILES.WALL;\n}\n\n/**\n * Pick ground tile using a checkerboard pattern for visual variety.\n */\nexport function pickGroundTile(x: number, y: number) {\n    return (x + y) % 2 === 0 ? TILES.GROUND : TILES.GROUND_ALT;\n}\n"
  },
  {
    "path": "frontend/src/components/GameBoard.tsx",
    "size": 6290,
    "content": "import { useRef, useEffect, useCallback, useState } from 'react';\nimport { GRID_W, GRID_H, DIR_UP, DIR_RIGHT, DIR_DOWN, DIR_LEFT } from '../constants';\nimport { useGameStore } from '../stores/gameStore';\nimport { TILE_SIZE, TILES, getTileSrc } from '../utils/tileMap';\n\nconst SCALE = 4;           // 16px Ã— 4 = 64px per cell\nconst CELL_PX = TILE_SIZE * SCALE;\nconst CANVAS_W = GRID_W * CELL_PX;\nconst CANVAS_H = GRID_H * CELL_PX;\n\n// Sprite sheet config (all 32Ã—32 per frame)\nconst SPRITE_SIZE = 32;\nconst base = import.meta.env.BASE_URL;\nconst SPRITE_SHEETS = {\n  idle:      { src: `${base}Pink_Monster_Idle_4.png`,      frames: 4 },\n  pushRight: { src: `${base}Pink_Monster_PushRight_6.png`, frames: 6 },\n  pushUp:    { src: `${base}Pink_Monster_PushUp_4.png`,    frames: 4 },\n} as const;\n\nconst ANIM_FPS = 8; // frames per second\n\ntype AnimKey = keyof typeof SPRITE_SHEETS;\n\nexport function GameBoard() {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const imgRef = useRef<HTMLImageElement | null>(null);\n  const spriteRefs = useRef<Record<AnimKey, HTMLImageElement | null>>({\n    idle: null, pushRight: null, pushUp: null,\n  });\n  const frameRef = useRef(0);\n  const animIdRef = useRef(0);\n\n  const getCellType = useGameStore((s) => s.getCellType);\n  const isGoal = useGameStore((s) => s.isGoal);\n  const levelData = useGameStore((s) => s.levelData);\n  const playerPos = useGameStore((s) => s.playerPos);\n  const boxPositions = useGameStore((s) => s.boxPositions);\n  const moveQueue = useGameStore((s) => s.moveQueue);\n\n  // Determine current animation based on last move direction\n  const lastDir = moveQueue.length > 0 ? moveQueue[moveQueue.length - 1] : null;\n\n  let currentAnim: AnimKey = 'idle';\n  let flipX = false;\n\n  if (lastDir === DIR_RIGHT) {\n    currentAnim = 'pushRight';\n    flipX = false;\n  } else if (lastDir === DIR_LEFT) {\n    currentAnim = 'pushRight';\n    flipX = true; // mirror horizontally\n  } else if (lastDir === DIR_UP) {\n    currentAnim = 'pushUp';\n    flipX = false;\n  } else if (lastDir === DIR_DOWN) {\n    currentAnim = 'pushUp';\n    flipX = true; // flip vertically via rotation trick â€” actually just mirror Y\n  }\n\n  // Load tileset + all sprite sheets once\n  useEffect(() => {\n    const tileImg = new Image();\n    tileImg.src = `${base}tileset.png`;\n    tileImg.onload = () => { imgRef.current = tileImg; };\n\n    (Object.keys(SPRITE_SHEETS) as AnimKey[]).forEach((key) => {\n      const sImg = new Image();\n      sImg.src = SPRITE_SHEETS[key].src;\n      sImg.onload = () => { spriteRefs.current[key] = sImg; };\n    });\n  }, []);\n\n  const draw = useCallback(() => {\n    const canvas = canvasRef.current;\n    const img = imgRef.current;\n    if (!canvas || !img || !levelData) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    ctx.imageSmoothingEnabled = false;\n    ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);\n\n    // === Layer 1: Ground (tile 5) ===\n    const { sx: gsx, sy: gsy } = getTileSrc(TILES.GROUND);\n    for (let y = 0; y < GRID_H; y++) {\n      for (let x = 0; x < GRID_W; x++) {\n        ctx.drawImage(img, gsx, gsy, TILE_SIZE, TILE_SIZE,\n          x * CELL_PX, y * CELL_PX, CELL_PX, CELL_PX);\n      }\n    }\n\n    // === Layer 2: Goals ===\n    for (let y = 0; y < GRID_H; y++) {\n      for (let x = 0; x < GRID_W; x++) {\n        if (isGoal(x, y)) {\n          const { sx, sy } = getTileSrc(TILES.GOAL);\n          ctx.drawImage(img, sx, sy, TILE_SIZE, TILE_SIZE,\n            x * CELL_PX, y * CELL_PX, CELL_PX, CELL_PX);\n        }\n      }\n    }\n\n    // === Layer 3: Walls (tile 0) ===\n    const { sx: wsx, sy: wsy } = getTileSrc(TILES.WALL_TOP);\n    for (let i = 0; i < levelData.wallXs.length; i++) {\n      const wx = levelData.wallXs[i];\n      const wy = levelData.wallYs[i];\n      ctx.drawImage(img, wsx, wsy, TILE_SIZE, TILE_SIZE,\n        wx * CELL_PX, wy * CELL_PX, CELL_PX, CELL_PX);\n    }\n\n    // === Layer 4: Boxes ===\n    boxPositions.forEach((box) => {\n      const { sx, sy } = getTileSrc(TILES.BOX);\n      ctx.drawImage(img, sx, sy, TILE_SIZE, TILE_SIZE,\n        box.x * CELL_PX, box.y * CELL_PX, CELL_PX, CELL_PX);\n\n      if (isGoal(box.x, box.y)) {\n        ctx.fillStyle = 'rgba(74, 222, 128, 0.35)';\n        ctx.fillRect(box.x * CELL_PX, box.y * CELL_PX, CELL_PX, CELL_PX);\n        ctx.fillStyle = '#ffffff';\n        ctx.font = `bold ${CELL_PX * 0.4}px sans-serif`;\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText('âœ“',\n          box.x * CELL_PX + CELL_PX / 2,\n          box.y * CELL_PX + CELL_PX / 2);\n      }\n    });\n\n    // === Layer 5: Player sprite ===\n    if (playerPos) {\n      const spriteImg = spriteRefs.current[currentAnim];\n      if (spriteImg) {\n        const sheet = SPRITE_SHEETS[currentAnim];\n        const frame = frameRef.current % sheet.frames;\n        const srcX = frame * SPRITE_SIZE;\n        const srcY = 0;\n\n        // Destination: center the 32Ã—32 sprite in the 64Ã—64 cell\n        // Scale sprite to fill cell\n        const dx = playerPos.x * CELL_PX;\n        const dy = playerPos.y * CELL_PX;\n\n        ctx.save();\n\n        if (flipX) {\n          // Mirror horizontally around the cell center\n          ctx.translate(dx + CELL_PX, dy);\n          ctx.scale(-1, 1);\n          ctx.drawImage(spriteImg,\n            srcX, srcY, SPRITE_SIZE, SPRITE_SIZE,\n            0, 0, CELL_PX, CELL_PX);\n        } else {\n          ctx.drawImage(spriteImg,\n            srcX, srcY, SPRITE_SIZE, SPRITE_SIZE,\n            dx, dy, CELL_PX, CELL_PX);\n        }\n\n        ctx.restore();\n      }\n    }\n  }, [levelData, playerPos, boxPositions, isGoal, currentAnim, flipX]);\n\n  // Animation loop â€” tick frames at ANIM_FPS\n  useEffect(() => {\n    frameRef.current = 0;\n    let lastTime = 0;\n    const interval = 1000 / ANIM_FPS;\n\n    function tick(time: number) {\n      if (time - lastTime >= interval) {\n        frameRef.current++;\n        lastTime = time;\n        draw();\n      }\n      animIdRef.current = requestAnimationFrame(tick);\n    }\n\n    animIdRef.current = requestAnimationFrame(tick);\n\n    return () => cancelAnimationFrame(animIdRef.current);\n  }, [draw]);\n\n  return (\n    <div className=\"board\">\n      <canvas\n        ref={canvasRef}\n        width={CANVAS_W}\n        height={CANVAS_H}\n        className=\"game-canvas\"\n      />\n    </div>\n  );\n}\n"
  },
  {
    "path": "frontend/src/components/Header.tsx",
    "size": 1126,
    "content": "import { ConnectButton } from '@mysten/dapp-kit-react';\nimport { useGameStore } from '../stores/gameStore';\nimport { LEVELS } from '../constants';\n\nexport function Header() {\n  const levelId = useGameStore((s) => s.levelId);\n  const level = levelId ? LEVELS.find((l) => l.id === levelId) : null;\n\n  return (\n    <header className=\"header\">\n      <div className=\"header-logo\">\n        <span className=\"emoji\">ğŸ“¦</span>\n        <h1>SOKOBAN</h1>\n        {level && <span className=\"header-badge\">Lv.{level.id} â€” {level.name}</span>}\n      </div>\n      <div className=\"header-info\">\n        <button\n          className=\"btn btn-danger\"\n          style={{ padding: '4px 10px', fontSize: 11 }}\n          onClick={() => { localStorage.clear(); window.location.reload(); }}\n        >\n          ğŸ—‘ Reset\n        </button>\n        <span className=\"header-badge\">testnet</span>\n        <div className=\"pixel-connect-wrapper\">\n          <span className=\"pixel-connect-label\">Connect</span>\n          <div className=\"pixel-connect-real\">\n            <ConnectButton />\n          </div>\n        </div>\n      </div>\n    </header>\n  );\n}\n"
  },
  {
    "path": "frontend/src/components/LevelSelect.tsx",
    "size": 2292,
    "content": "import { useState } from 'react';\nimport { LEVELS } from '../constants';\nimport { useGameActions } from '../hooks/useGameActions';\nimport { useGameStore } from '../stores/gameStore';\n\ninterface Props {\n  onLevelStarted: () => void;\n}\n\nexport function LevelSelect({ onLevelStarted }: Props) {\n  const { startLevel } = useGameActions();\n  const initLevel = useGameStore((s) => s.initLevel);\n  const [loading, setLoading] = useState<number | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  async function handleSelect(levelId: number) {\n    setLoading(levelId);\n    setError(null);\n    try {\n      const { playerEntityId, boxEntityIds, sessionId, gridId } = await startLevel(levelId);\n      initLevel(levelId, sessionId, gridId, playerEntityId, boxEntityIds);\n      onLevelStarted();\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to start level');\n    } finally {\n      setLoading(null);\n    }\n  }\n\n  return (\n    <div className=\"level-select\">\n      <h2>Select Level</h2>\n      <p className=\"subtitle\">Push all boxes onto the goal tiles. Fewer moves = better score.</p>\n\n      {error && <div className=\"error-msg\" style={{ marginBottom: 16 }}>{error}</div>}\n\n      <div className=\"level-grid\">\n        {LEVELS.map((level) => (\n          <div\n            key={level.id}\n            className={`level-card ${loading !== null ? 'disabled' : ''}`}\n            onClick={() => handleSelect(level.id)}\n          >\n            <div className=\"level-number\">Level {level.id}</div>\n            <div className=\"level-name\">{level.name}</div>\n            <div className=\"level-meta\">\n              <span className={`tag ${level.difficulty.toLowerCase()}`}>\n                {level.difficulty}\n              </span>\n              <span className=\"tag info\">{level.boxes} boxes</span>\n              <span className=\"tag info\">â‰¤{level.maxMoves} moves</span>\n            </div>\n            {loading === level.id && (\n              <div style={{ marginTop: 12, display: 'flex', alignItems: 'center', gap: 6 }}>\n                <div className=\"spinner\" />\n                <span style={{ fontSize: 12, color: 'var(--text-secondary)' }}>Starting...</span>\n              </div>\n            )}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n"
  },
  {
    "path": "frontend/src/components/MoveControls.tsx",
    "size": 3186,
    "content": "import { useEffect, useCallback } from 'react';\nimport { DIR_UP, DIR_RIGHT, DIR_DOWN, DIR_LEFT } from '../constants';\nimport { useGameStore } from '../stores/gameStore';\n\nexport function MoveControls() {\n  const addMove = useGameStore((s) => s.addMove);\n  const undoMove = useGameStore((s) => s.undoMove);\n  const resetMoves = useGameStore((s) => s.resetMoves);\n  const moveQueue = useGameStore((s) => s.moveQueue);\n  const getDirectionName = useGameStore((s) => s.getDirectionName);\n  const levelData = useGameStore((s) => s.levelData);\n  const isSolved = useGameStore((s) => s.isSolved);\n\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      switch (e.key) {\n        case 'ArrowUp':\n        case 'w':\n          e.preventDefault();\n          addMove(DIR_UP);\n          break;\n        case 'ArrowRight':\n        case 'd':\n          e.preventDefault();\n          addMove(DIR_RIGHT);\n          break;\n        case 'ArrowDown':\n        case 's':\n          e.preventDefault();\n          addMove(DIR_DOWN);\n          break;\n        case 'ArrowLeft':\n        case 'a':\n          e.preventDefault();\n          addMove(DIR_LEFT);\n          break;\n        case 'z':\n          if (e.metaKey || e.ctrlKey) {\n            e.preventDefault();\n            undoMove();\n          }\n          break;\n        case 'r':\n          if (e.metaKey || e.ctrlKey) {\n            e.preventDefault();\n            resetMoves();\n          }\n          break;\n      }\n    },\n    [addMove, undoMove, resetMoves]\n  );\n\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  const solved = isSolved();\n  const maxMoves = levelData?.maxMoves ?? 0;\n\n  return (\n    <div className=\"controls\">\n      {/* Move queue display */}\n      <div className=\"move-queue\">\n        {moveQueue.length === 0 ? (\n          <span style={{ color: 'var(--text-muted)', fontSize: 12 }}>\n            Use arrow keys or D-pad to move\n          </span>\n        ) : (\n          moveQueue.map((dir, i) => (\n            <span key={i} className=\"move-arrow\">\n              {getDirectionName(dir)}\n            </span>\n          ))\n        )}\n      </div>\n\n\n\n      {/* Move counter */}\n      <div style={{ fontSize: 12, color: 'var(--text-secondary)' }}>\n        {moveQueue.length} / {maxMoves} moves\n        {solved && <span style={{ marginLeft: 8, color: 'var(--cell-box-on-goal)' }}>âœ“ Solved!</span>}\n      </div>\n\n      {/* Action buttons */}\n      <div className=\"action-bar\">\n        <button\n          className=\"btn btn-secondary\"\n          onClick={undoMove}\n          disabled={moveQueue.length === 0}\n        >\n          â†© Undo\n        </button>\n        <button\n          className=\"btn btn-danger\"\n          onClick={resetMoves}\n          disabled={moveQueue.length === 0}\n        >\n          âŸ² Reset\n        </button>\n      </div>\n\n      <div className=\"keyboard-hint\">\n        <kbd>â†‘</kbd> <kbd>â†“</kbd> <kbd>â†</kbd> <kbd>â†’</kbd> or <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd>\n        &nbsp;Â·&nbsp; <kbd>âŒ˜Z</kbd> undo &nbsp;Â·&nbsp; <kbd>âŒ˜R</kbd> reset\n      </div>\n    </div>\n  );\n}\n"
  },
  {
    "path": "frontend/src/components/SpriteAnimation.tsx",
    "size": 1646,
    "content": "import { useRef, useEffect } from 'react';\n\ninterface Props {\n  src: string;\n  frameCount: number;\n  frameWidth?: number;\n  frameHeight?: number;\n  fps?: number;\n  scale?: number;\n  className?: string;\n}\n\n/**\n * Renders an animated sprite from a horizontal sprite sheet on a canvas.\n */\nexport function SpriteAnimation({\n  src,\n  frameCount,\n  frameWidth = 32,\n  frameHeight = 32,\n  fps = 8,\n  scale = 4,\n  className,\n}: Props) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    const img = new Image();\n    img.src = src;\n\n    let frame = 0;\n    let animId = 0;\n    let lastTime = 0;\n    const interval = 1000 / fps;\n\n    function tick(time: number) {\n      if (time - lastTime >= interval) {\n        frame = (frame + 1) % frameCount;\n        lastTime = time;\n\n        ctx!.imageSmoothingEnabled = false;\n        ctx!.clearRect(0, 0, frameWidth * scale, frameHeight * scale);\n        ctx!.drawImage(\n          img,\n          frame * frameWidth, 0, frameWidth, frameHeight,\n          0, 0, frameWidth * scale, frameHeight * scale,\n        );\n      }\n      animId = requestAnimationFrame(tick);\n    }\n\n    img.onload = () => {\n      animId = requestAnimationFrame(tick);\n    };\n\n    return () => cancelAnimationFrame(animId);\n  }, [src, frameCount, frameWidth, frameHeight, fps, scale]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      width={frameWidth * scale}\n      height={frameHeight * scale}\n      className={className}\n      style={{ imageRendering: 'pixelated' }}\n    />\n  );\n}\n"
  }
];
